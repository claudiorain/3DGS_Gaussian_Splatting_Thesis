\chapter{Architettura del Sistema Proposto}
\label{chap:architettura}

\section{Obiettivi e funzionalità del sistema}
Il sistema proposto è stato progettato per affrontare direttamente le limitazioni per l'adozione diffusa del 3D Gaussian Splatting identificate nel capitolo precedente, trasformando una tecnologia prevalentemente accademica in una soluzione accessibile e user-friendly.

\subsection{Obiettivi di progetto}

\paragraph{Migliore accesso alla  tecnologia}
L'obiettivo primario consiste nel rendere il 3D Gaussian Splatting accessibile a utenti senza competenze tecniche specialistiche in computer graphics o machine learning. Il sistema deve eliminare le barriere di ingresso tipiche degli strumenti di ricerca, permettendo a professionisti di settori diversi - dal design alla produzione multimediale - di sfruttare le potenzialità della tecnologia attraverso un'interfaccia intuitiva.

\paragraph{Unificazione di strumenti frammentati}
Il secondo obiettivo riguarda l'integrazione di funzionalità attualmente disperse in implementazioni separate. Il sistema deve fornire una piattaforma unificata che comprenda training, visualizzazione e gestione modelli, eliminando la necessità di utilizzare tool specifici incompatibili tra loro e riducendo significativamente la curva di apprendimento.

\paragraph{Automazione del workflow tecnico}
Il terzo obiettivo è l'automazione dell'intero processo, dalla preparazione dei dati alla visualizzazione finale, riducendo al minimo l'intervento manuale e la possibilità di errori. Questo include la gestione automatica di preprocessing, configurazione parametri e troubleshooting di problemi comuni.

\subsection{Funzionalità del sistema}
Per raggiungere questi obiettivi, il sistema implementa le seguenti funzionalità core:

\paragraph{Interfaccia web guidata}\mbox{}\\
Il sistema fornisce un'interfaccia web responsive che guida l'utente attraverso un processo step-by-step, dalla selezione del video di input alla visualizzazione del modello 3D finale. L'interfaccia integra:

\begin{itemize}
\item \textbf{Processo guidato}: Workflow sequenziale con istruzioni chiare per ogni fase
\item \textbf{Validazione intelligente}: Controllo automatico della qualità e formato dei file di input
\item \textbf{Feedback}: Indicatore della fase in cui si trovano le elaborazioni
\item \textbf{Documentazione contestuale}: Spiegazioni integrate e suggerimenti per ottimizzare i risultati
\end{itemize}

\paragraph{Training multi-algoritmo integrato}\mbox{}\\
La piattaforma integra tre diversi approcci di training del Gaussian Splatting in un'unica interfaccia:

\begin{itemize}
\item \textbf{Standard 3DGS}: Implementazione baseline per risultati di alta qualità
\item \textbf{MCMC Gaussian Splatting}: Approccio probabilistico per miglioramento della qualità e riduzione artefatti
\item \textbf{Taming 3DGS}: Ottimizzazione per risorse computazionali limitate
\end{itemize}

L'utente può selezionare l'algoritmo desiderato attraverso un'interfaccia semplificata, con parametri preconfigurati per casi d'uso comuni e opzioni avanzate per utenti esperti.

\paragraph{Pipeline di processing automatizzata}\mbox{}\\
Il sistema implementa una pipeline completamente automatizzata che gestisce:

\begin{itemize}
\item \textbf{Preprocessing video}: Estrazione automatica di frame ottimali dal video di input
\item \textbf{Structure from Motion}: Generazione automatica della point cloud iniziale
\item \textbf{Training asincrono}: Elaborazione in background con notifiche di completamento
\item \textbf{Post-processing}: Generazione e salvataggio delle metriche di elaborazione
\end{itemize}

\paragraph{Visualizzazione 3D integrata}\mbox{}\\
La piattaforma include un viewer 3D web-based che permette:

\begin{itemize}
\item \textbf{Rendering real-time}: Visualizzazione immediata dei modelli generati
\item \textbf{Controlli interattivi}: Navigazione 3D intuitiva con mouse/touch
\item \textbf{Valutazione}: Visualizzazione delle statistiche come FPS e numero di gaussiane generate
\end{itemize}

\paragraph{Gestione trasparente delle risorse}\mbox{}\\
Il sistema nasconde la complessità tecnica attraverso:

\begin{itemize}
\item \textbf{Containerizzazione}: Ambiente di esecuzione isolato e riproducibile
\item \textbf{Gestione automatica GPU}: Allocazione ottimale delle risorse computazionali
\item \textbf{Scaling adattivo}: Gestione automatica del carico di lavoro
\item \textbf{Monitoring integrato}: Raccolta automatica di metriche di performance e qualità
\end{itemize}

\subsection{Benefici attesi}

L'implementazione di queste funzionalità mira a produrre i seguenti benefici:
\begin{itemize}
    \item \textbf{Riduzione time-to-market}: Dalla creazione del contenuto alla visualizzazione 3D in minuti invece che ore o giorni richiesti da workflow tradizionali.
    \item \textbf{Accessibilità ampliata}: Estensione dell'utilizzo del 3D Gaussian Splatting a settori non tecnici come marketing, e-commerce, architettura e produzione di contenuti.
    \item \textbf{Standardizzazione del processo}: Etablishment di best practices e workflow standardizzati per la creazione di contenuti 3D da video.
    \item \textbf{Riduzione costi}: Eliminazione della necessità di competenze specialistiche dedicate e riduzione dei tempi di training del personale.
\end{itemize}

\section{Architettura a microservizi}

\subsection{Design pattern e principi architetturali}
La scelta di un'architettura a microservizi per il 3D Gaussian Splatting è motivata dalle specifiche caratteristiche computazionali e operative di questa tecnologia, che presenta sfide uniche rispetto ad applicazioni web tradizionali.

\paragraph{Separazione delle responsabilità per processing intensivo}\mbox{}\\
Il training del Gaussian Splatting richiede risorse computazionali altamente specializzate, in particolare GPU con elevata VRAM, e tempi di elaborazione che possono variare da alcuni minuti a diverse ore. Sebbene un'architettura monolitica possa gestire processing asincrono 
attraverso threading, l'approccio a microservizi offre vantaggi specifici 
per il Gaussian Splatting: isolamento degli errori hardware-intensive, 
scalabilità selettiva delle risorse GPU, e deployment indipendente di 
algoritmi in evoluzione.
L'approccio a microservizi permette di separare logicamente:

\begin{itemize}
    \item \textbf{Servizi di interfaccia}: Frontend e API che rimangono sempre responsivi
    \item \textbf{Servizi di processing}: Dedicati esclusivamente al training intensivo
    \item \textbf{Servizi di supporto}: Gestione dati, code messaggi e storage
\end{itemize}


Queste funzionalità si traducono in un'architettura tecnica specifica che verrà dettagliata nelle sezioni successive, dimostrando come gli obiettivi di alto livello si concretizzino in scelte implementative precise.

\paragraph{\textbf{Scalabilità orizzontale specializzata}}\mbox{}\\
La natura del training di Gaussian Splatting, che richiede hardware dedicato (GPU), rende particolarmente vantaggiosa la possibilità di scalare orizzontalmente solo i componenti computazionalmente intensivi. I servizi di training, essendo containerizzati e stateless, possono essere deployati su multiple macchine dotate di GPU specializzate, mentre frontend e API rimangono centralizzati su hardware meno specializzato.
Questa separazione consente di:

\begin{itemize}
    \item \textbf{Ottimizzare i costi}: Hardware GPU costoso utilizzato solo per training e il preprocessing
    \item \textbf{Gestire il carico}: Aggiungere capacità computazionale senza modificare altri servizi
    \item Isolamento degli errori: Crash o indisponibilità del training non compromette l'interfaccia utente
\end{itemize}

\paragraph{\textbf{Continuous integration e deployment indipendente}}\mbox{}\\
L'architettura modulare facilita lo sviluppo e la manutenzione del sistema, permettendo di aggiornare, testare e deployare ogni componente indipendentemente. Questo è particolarmente vantaggioso per un progetto che integra algoritmi di training in evoluzione (Standard, MCMC, Taming), dove ogni implementazione può essere aggiornata senza impattare gli altri moduli.

\subsection{Containerizzazione con Docker e Docker Compose}
\paragraph{\textbf{Isolamento delle dipendenze specializzate}}\mbox{}\\
Ogni algoritmo di training del Gaussian Splatting presenta dipendenze specifiche e spesso conflittuali:

\begin{itemize}
    \item \textbf{Versioni CUDA}: Diverse implementazioni richiedono versioni specifiche di CUDA (driver NVIDIA)
    \item \textbf{Librerie Python}: Conflitti tra versioni di PyTorch, NumPy e librerie di computer vision
    \item \textbf{Configurazioni hardware}: Ottimizzazioni specifiche per GPU diverse
\end{itemize}

\paragraph{\textbf{Orchestrazione con Docker Compose}}\mbox{}\\
Docker Compose facilita la gestione dell'intero stack applicativo, definendo in modo dichiarativo:

\begin{itemize}
    \item \textbf{Networking}: Comunicazione sicura tra container
    \item \textbf{Volume mounting}: Condivisione dati tra servizi
    \item \textbf{Environment variables}: Configurazione centralizzata
    \item \textbf{Service dependencies}: Ordine di avvio dei servizi
\end{itemize}

Sebbene il deployment attuale avvenga su singola macchina per ragioni di sviluppo, l'architettura containerizzata prepara il sistema per un futuro deployment distribuito su cluster.

\paragraph{\textbf{Gestione risorse GPU}}\mbox{}\\
La containerizzazione permette di gestire in modo granulare l'accesso alle risorse GPU, garantendo che il container di training abbia accesso esclusivo alle GPU disponibili, evitando conflitti di risorse e ottimizzando le performance.

\subsection{Pattern architetturali implementati} 
\paragraph{\textbf{Event-Driven Architecture}}\mbox{}\\
Il sistema implementa un'architettura guidata dagli eventi attraverso una coda di messaggi che coordina l'esecuzione delle diverse fasi di processing. Ogni completamento di fase genera un evento che triggera la fase successiva, creando un workflow asincrono e resiliente.\newline\newline
\textbf{Vantaggi per il Gaussian Splatting}:
\begin{itemize}
    \item \textbf{Gestione della coda}: Serializzazione automatica dei job per gestire la limitazione di GPU singola
    \item \textbf{Retry automatico}: Eventi possono essere riaccodati in caso di fallimento
    \item \textbf{Monitoring}: Stato del workflow tracciabile attraverso gli eventi
\end{itemize}

\paragraph{\textbf{Pipeline Pattern}}\mbox{}\\
Il processing del Gaussian Splatting segue naturalmente un pattern pipeline con handoff espliciti tra fasi:

\begin{itemize}
    \item \textbf{Estrazione frame} → Output: frame video + metadati
    \item \textbf{Structure from Motion} → Output: point cloud + pose camere
    \item \textbf{Training} → Output: modello 3D ottimizzato
\end{itemize}

Ogni fase produce output standardizzati che vengono consumati dalla fase successiva, permettendo parallelizzazione e reprocessing selettivo.

\paragraph{\textbf{Cache-Aside Pattern}}\mbox{}\\
Il sistema implementa una strategia di caching a due livelli per ottimizzare l'accesso ai dati:

\begin{algorithm}
\caption{Cache-Aside Pattern per gestione risorse}
\SetAlgoLined
\KwIn{resource\_identifier}
\KwOut{resource\_data}

\eIf{resource exists in local\_cache}{
    \Return{load\_from\_local\_cache(resource\_identifier)}\;
}{
    resource\_data $\leftarrow$ fetch\_from\_remote\_storage(resource\_identifier)\;
    save\_to\_local\_cache(resource\_identifier, resource\_data)\;
    \Return{resource\_data}\;
}
\end{algorithm}

Questo riduce significativamente i costi e i tempi di accesso a S3, particolarmente importante per file di grandi dimensioni tipici del Gaussian Splatting.

\paragraph{\textbf{Staging Pattern}}\mbox{}\\
Amazon S3 funge da storage intermedio tra le fasi, implementando un pattern staging che permette:

\begin{itemize}
    \item \textbf{Persistenza}: Risultati intermedi sopravvivono a restart dei servizi
    \item \textbf{Reprocessing}: Possibilità di ripartire da fasi specifiche
    \item \textbf{Auditability}: Tracciabilità completa dei dati prodotti
\end{itemize}

\subsection{Gestione asincrona e code messaggi}
Il sistema implementa una gestione asincrona delle richieste attraverso un'architettura di messaggistica leggera. Ogni messaggio in coda contiene esclusivamente l'identificativo univoco del modello, mentre tutti i dati necessari per l'esecuzione vengono recuperati dinamicamente da MongoDB all'inizio di ciascuna fase.\newline

\textbf{Architettura della coda}: Il sistema utilizza code separate per ogni fase del workflow (estrazione, SfM, training), dove vengono accodati solamente gli ID dei modelli da processare. Questo approccio mantiene i messaggi leggeri ed evita ridondanza di dati nelle code.
\newline

\textbf{Recupero dinamico dei dati}: All'avvio di ogni fase, la funzione dedicata recupera dal database tutte le informazioni necessarie (parametri di configurazione, stato precedente, metadati del progetto), garantendo sempre l'utilizzo dello stato più aggiornato del modello.
\newline

\textbf{Serializzazione GPU}: I job di training vengono automaticamente serializzati per gestire la limitazione hardware della singola GPU, mantenendo l'ordine di arrivo delle richieste mentre le fasi preparatorie possono essere elaborate in parallelo.
\newline

\textbf{Gestione dei fallimenti}: Quando una fase fallisce, il processo si arresta in stato controllato, permettendo analisi del problema e retry mirato. Il reprocessing selettivo consente di rigenerare un modello partendo da una fase specifica già completata senza dover riprocessare l'intero workflow.
\newline

Questa architettura offre flessibilità operativa mantenendo l'efficienza delle risorse e la consistenza dei dati, elementi cruciali per un sistema di elaborazione 3D ad alta intensità computazionale.

\paragraph{\textbf{Comunicazione inter-servizi}}\mbox{}\\
La comunicazione tra servizi segue pattern consolidati:

\begin{itemize}
    \item \textbf{Sincrona}: API REST per operazioni immediate (upload, status queries)
    \item \textbf{Asincrona}: Message queue per operazioni long-running (training)
\end{itemize}

\subsection{Storage e caching strategy}
\paragraph{\textbf{Architettura storage ibrida}}\mbox{}\\
Il sistema utilizza una strategia storage ibrida ottimizzata per i pattern di accesso del Gaussian Splatting:
\paragraph{\textbf{Storage locale:}} Cache temporanea per file in elaborazione attiva

\begin{itemize}
    \item Accesso veloce durante processing
    \item Riduzione latenza I/O
    \item Automatic cleanup per gestione spazio
\end{itemize}

\paragraph{\textbf{Amazon S3:}} Repository persistente per dati e risultati

\begin{itemize}
    \item Durabilità e availability
    \item Scalabilità storage
    \item Versioning e backup automatico
\end{itemize}

\paragraph{\textbf{Gestione del ciclo di vita dei dati}}\mbox{}\\
La strategia di storage considera il ciclo di vita tipico dei progetti Gaussian Splatting attraverso un approccio che privilegia la funzionalità del reprocessing e la semplicità gestionale:

\paragraph{\textbf{Input phase:}} I video caricati dall'utente vengono archiviati permanentemente in S3 Standard sotto il path videos/, garantendo disponibilità costante per operazioni di reprocessing. Questa persistenza è essenziale per mantenere la capacità di rigenerare modelli con parametri diversi senza dover richiedere nuovamente il contenuto all'utente.
\paragraph{\textbf{Processing phase:}} I file intermedi generati durante l'elaborazione (image extraction, point clouds, dati SfM) vengono salvati su storage locale per massimizzare le performance di I/O durante le fasi computazionalmente intensive. Questi dati rimangono disponibili per supportare operazioni di reprocessing parziale.
\paragraph{\textbf{Delivery phase:}} I modelli finali vengono archiviati su S3 Standard nella stessa struttura organizzativa del progetto, permettendo download diretto da parte degli utenti attraverso URL presigned temporanei.
\newline
\newline
L'architettura attuale mantiene tutti i dati persistenti per massimizzare la flessibilità operativa, con la consapevolezza che future ottimizzazioni potranno introdurre politiche di cleanup automatico per i dati intermedi non critici. Questo approccio conservativo garantisce la stabilità del workflow di reprocessing, elemento centrale per l'esperienza utente del sistema.

\section{Componenti del Sistema}

Il sistema proposto è articolato in sette componenti principali, ciascuno con responsabilità specifiche e ben definite. La separazione delle responsabilità segue i principi di \textit{Single Responsibility} e \textit{Separation of Concerns}, garantendo modularità e manutenibilità.

\subsection{Frontend: Interfaccia Utente e Visualizzazione 3D}

Il frontend costituisce il punto di accesso per gli utenti finali e ha la responsabilità di fornire un'interfaccia intuitiva per l'upload dei video e la visualizzazione dei risultati. Il componente integra capacità di rendering 3D per permettere la visualizzazione interattiva dei modelli Gaussian Splatting generati.

\noindent Le funzionalità principali del frontend includono:
\begin{itemize}
    \item \textbf{Upload video}: interfaccia per il caricamento di contenuti multimediali, con supporto per diversi formati video
    \item \textbf{Gestione modelli}: listato dei modelli elaborati con funzionalità di ricerca e filtraggio per nome
    \item \textbf{Visualizzatore 3D}: ambiente interattivo per l'esplorazione dei modelli generati con controlli di navigazione e manipolazione della vista
    \item \textbf{Clonazione e configurazione}: sistema di clonazione di modelli esistenti (anche da elaborazioni fallite) con possibilità di modificare parametri di training, algoritmi e livelli di qualità, permettendo di ripartire da step di elaborazione già completati
\end{itemize}

\noindent La scelta di un frontend dedicato permette di ottimizzare l'esperienza utente e di gestire la complessità del rendering 3D senza impattare sulle performance degli altri servizi.


\subsection{Backend API: Gestione Richieste e Coordinamento}

Il Backend API funge da intermediario tra il frontend e i servizi di elaborazione, esponendo le interfacce REST per la comunicazione con l'interfaccia utente. Questo componente gestisce le operazioni CRUD sui modelli, permettendo la lettura dei modelli esistenti e la creazione di nuovi training sia da zero che a partire da modelli preesistenti.

Le responsabilità principali includono:
\begin{itemize}
    \item \textbf{Gestione modelli}: operazioni di lettura, creazione e clonazione dei modelli di training
    \item \textbf{Coordinamento training}: inserimento dei job di training nella coda di elaborazione
    \item \textbf{Autenticazione}: gestione dell'autenticazione delle richieste provenienti dal frontend
    \item \textbf{Interfaccia REST}: esposizione di endpoint per la comunicazione con il frontend
\end{itemize}

La centralizzazione di queste operazioni in un componente dedicato garantisce un punto di controllo unico per l'accesso ai dati e la gestione dei workflow di elaborazione.

\subsection{Video Processing Service: Estrazione Frame e Preprocessing}

Il servizio di processing video rappresenta una componente logica del sistema che si occupa dell'analisi e della preparazione dei contenuti multimediali in input. Questa funzionalità è integrata all'interno del Training Service e interviene principalmente nella fase iniziale dei job di elaborazione.

Le responsabilità principali includono:
\begin{itemize}
    \item \textbf{Estrazione frame}: conversione dei video in sequenze di frame utilizzando la libreria Sharp Frames Python
    \item \textbf{Preprocessing}: preparazione dei frame per le successive fasi di training
    \item \textbf{Validazione input}: verifica della conformità tecnica dei contenuti multimediali
\end{itemize}

\subsection{Point Cloud Reconstruction Service: Structure from Motion}

Il servizio di ricostruzione della nuvola di punti rappresenta il ponte tra l'estrazione dei frame e il training degli algoritmi di Gaussian Splatting. Questo componente si occupa della generazione della rappresentazione geometrica iniziale tramite tecniche di Structure from Motion.

Le responsabilità principali includono:
\begin{itemize}
	\item \textbf{Camera pose estimation}: calcolo delle posizioni e orientamenti delle camere per ogni frame
	\item \textbf{Sparse point cloud generation}: ricostruzione geometrica 3D della scena come input per il training
\end{itemize}

Il servizio è implementato come container dedicato basato su COLMAP, garantendo isolamento delle dipendenze e ottimizzazione specifica per algoritmi di computer vision.

\subsection{Training Service: Motore di Training con Algoritmi Multipli}

Il Training Service rappresenta il cuore computazionale del sistema, responsabile dell'esecuzione degli algoritmi di Gaussian Splatting. Il servizio supporta multiple implementazioni algoritmiche (Standard, MCMC, Taming) permettendo agli utenti di scegliere il trade-off ottimale tra qualità e prestazioni. La modularità di questo componente facilita l'integrazione di nuovi algoritmi e l'ottimizzazione specifica per diverse tipologie di contenuti.

\subsection{Message Queue: Sistema di Comunicazione Asincrona}

Il sistema di code messaggi gestisce la comunicazione asincrona tra i componenti, disaccoppiando le operazioni temporalmente intensive dalle richieste utente. Questo componente garantisce la resilienza del sistema attraverso meccanismi di retry e fault tolerance, permettendo la gestione di picchi di carico e la distribuzione del lavoro su multiple istanze dei servizi.

\subsection{Database: Persistenza Metadati e Stato Elaborazioni}

Il database centralizza la persistenza dei metadati relativi alle elaborazioni, inclusi stati, parametri di configurazione, e informazioni sui job di training. La separazione tra dati strutturati (metadati) e contenuti multimediali (gestiti dall'Object Storage) ottimizza le performance di query e semplifica la gestione del ciclo di vita dei dati.

\subsection{Object Storage: Archiviazione Media}

L'Object Storage gestisce l'archiviazione scalabile di tutti i contenuti multimediali del sistema: video originali, frame estratti, e modelli 3D generati. Questo componente garantisce durabilità, disponibilità e performance ottimali per contenuti di grandi dimensioni, supportando pattern di accesso sia sequenziali che casuali.

\section{Flusso di elaborazione end-to-end}
Il flusso di elaborazione del sistema segue un approccio sequenziale orchestrato attraverso code di messaggi specializzate. Ogni fase del workflow è gestita da job specifici che, una volta completati, innescano automaticamente la fase successiva della pipeline.
\subsection{Fase di Upload e Inizializzazione}
Il processo inizia con l'upload del video da parte dell'utente attraverso il frontend. Il sistema implementa un meccanismo di upload sicuro basato su presigned URL: il frontend richiede al backend un URL temporaneo per il caricamento diretto sull'object storage, evitando il transito del contenuto multimediale attraverso il backend API. Completato l'upload, il frontend effettua una richiesta POST di creazione del modello, specificando i parametri di training (algoritmo, livello di qualità, nome progetto).
\subsection{Pipeline di Elaborazione}
Il backend persiste i metadati del nuovo modello nel database e inserisce il primo job della catena nella coda di messaggi. Il flusso di elaborazione è strutturato in cinque fasi sequenziali:
\begin{enumerate}
\item \textbf{Frame Extraction}: estrazione dei frame dal video caricato
\item \textbf{Cloud Point Reconstruction}: generazione della nuvola di punti iniziale
\item \textbf{Training}: esecuzione dell'algoritmo di Gaussian Splatting selezionato
\item \textbf{Upload}: caricamento del modello 3D generato sull'object storage
\item \textbf{Metrics Generation}: calcolo delle metriche di qualità del modello
\end{enumerate}
\subsection{Coordinamento tra Job}
Il sistema adotta un'architettura a code specializzate, dove ogni tipologia di job dispone di una coda dedicata. Al completamento di ciascun job, il job executor inserisce automaticamente il task successivo nella coda appropriata, garantendo la continuità del flusso di elaborazione. Questa architettura permette una gestione granulare delle risorse e una scalabilità indipendente per ogni fase del workflow.
\subsection{Gestione dei Fallimenti}
In caso di fallimento di un job, il flusso di elaborazione si interrompe e il modello viene marcato con stato di errore. Il sistema non implementa meccanismi automatici di retry, ma permette all'utente di riavviare manualmente l'elaborazione dal frontend, sfruttando la funzionalità di clonazione del modello per ripartire da eventuali step già completati con successo.


\begin{figure}[htbp]
\centering
\vspace*{-1cm} % Riduci spazio sopra la figura
\adjustbox{width=0.5\textwidth,center,keepaspectratio}{
\includegraphics{images/upload_preparazione.jpg}
}
\vspace*{-0.5cm} % Riduci spazio tra figura e didascalia
\caption{Architettura dei componenti del sistema (upload e preprocessing video)}
\label{fig:component_architecture1}
\end{figure}

\begin{figure}[htbp]
\centering
\vspace*{-3cm} % Riduci spazio sopra la figura
\adjustbox{width=0.5\textwidth,center,keepaspectratio}{
\includegraphics{images/elaborazione_training.jpg}
}
\vspace*{-0.5cm} % Riduci spazio tra figura e didascalia
\caption{Architettura dei componenti del sistema (elaborazione e training)}
\label{fig:component_architecture2}
\end{figure}

\begin{figure}[htbp]
\centering
\vspace*{-1cm} % Riduci spazio sopra la figura
\adjustbox{width=0.6\textwidth,center,keepaspectratio}{
\includegraphics{images/finalizzazione.jpg}
}
\vspace*{-0.5cm} % Riduci spazio tra figura e didascalia
\caption{Architettura dei componenti del sistema (finalizzazione)}
\label{fig:component_architecture}
\end{figure}
\section{Scelte tecnologiche e motivazioni}
Le scelte tecnologiche del sistema sono state guidate da criteri di semplicità, efficacia e adeguatezza al dominio applicativo, evitando sovraingegnerizzazioni non necessarie per il contesto di sviluppo.
\subsection{Frontend e Visualizzazione}
Per il frontend è stato scelto \textbf{Vue.js 3}, framework che offre un ottimo compromesso tra semplicità e funzionalità per lo sviluppo di Single Page Application. Vue.js risulta più adatto rispetto ad alternative come Angular, che si rivela più appropriato per progetti enterprise multi-modulo di maggiore complessità.
Per la visualizzazione 3D dei modelli Gaussian Splatting è stata adottata la libreria \textbf{GaussianSplats3D}, un'implementazione specializzata basata su Three.js. Questa scelta è motivata dalla necessità di supportare il rendering di Gaussian Splats, non nativamente supportato da Three.js standard. Nonostante alcune limitazioni (supporto limitato al secondo grado di armoniche sferiche), rappresenta attualmente la soluzione più matura disponibile.
\subsection{Backend e Orchestrazione}
Il backend è implementato in \textbf{Python}, scelta dettata principalmente dall'ecosistema dei metodi di training utilizzati. I tre algoritmi implementati (Standard Gaussian Splatting, MCMC, Taming-3DGS) sono stati integrati come container separati che espongono interfacce REST, permettendo un'architettura modulare e facilitando future estensioni.
\subsection{Infrastruttura e Persistenza}
\textbf{RabbitMQ} è stato scelto come message broker per la sua affidabilità, facilità di configurazione e supporto nativo per pattern di messaging complessi. La scelta garantisce robustezza nella gestione delle code e semplicità di deployment.
Per la persistenza è stato adottato \textbf{MongoDB}, database NoSQL che si adatta meglio alla natura semi-strutturata dei metadati del sistema rispetto a soluzioni relazionali tradizionali. La flessibilità dello schema facilita l'evoluzione del data model durante lo sviluppo.
\textbf{Amazon S3} è utilizzato come object storage per la sua affidabilità, scalabilità e per la disponibilità di piani gratuiti per studenti. La scelta permette di gestire efficacemente i contenuti multimediali di grandi dimensioni.
\subsection{Containerizzazione e Deployment}
La containerizzazione è realizzata tramite \textbf{Docker e Docker Compose}, soluzione che offre un ottimo equilibrio tra semplicità di gestione e funzionalità. Kubernetes è stato deliberatamente evitato in quanto ritenuto eccessivamente complesso per il contesto applicativo e le dimensioni del progetto, rappresentando un caso di potenziale sovraingegnerizzazione.